// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DATATYPES_PANDORA_SERIALIZATION_H_
#define FLATBUFFERS_GENERATED_DATATYPES_PANDORA_SERIALIZATION_H_

#include "flatbuffers/flatbuffers.h"

namespace pandora {
namespace serialization {

struct Vec3;

struct Bounds;

struct Mat4;

struct Transform;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Bounds FLATBUFFERS_FINAL_CLASS {
 private:
  Vec3 min_;
  Vec3 max_;

 public:
  Bounds() {
    memset(this, 0, sizeof(Bounds));
  }
  Bounds(const Vec3 &_min, const Vec3 &_max)
      : min_(_min),
        max_(_max) {
  }
  const Vec3 &min() const {
    return min_;
  }
  Vec3 &mutable_min() {
    return min_;
  }
  const Vec3 &max() const {
    return max_;
  }
  Vec3 &mutable_max() {
    return max_;
  }
};
FLATBUFFERS_STRUCT_END(Bounds, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Mat4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x0_;
  float x1_;
  float x2_;
  float x3_;
  float y0_;
  float y1_;
  float y2_;
  float y3_;
  float z0_;
  float z1_;
  float z2_;
  float z3_;
  float w0_;
  float w1_;
  float w2_;
  float w3_;

 public:
  Mat4() {
    memset(this, 0, sizeof(Mat4));
  }
  Mat4(float _x0, float _x1, float _x2, float _x3, float _y0, float _y1, float _y2, float _y3, float _z0, float _z1, float _z2, float _z3, float _w0, float _w1, float _w2, float _w3)
      : x0_(flatbuffers::EndianScalar(_x0)),
        x1_(flatbuffers::EndianScalar(_x1)),
        x2_(flatbuffers::EndianScalar(_x2)),
        x3_(flatbuffers::EndianScalar(_x3)),
        y0_(flatbuffers::EndianScalar(_y0)),
        y1_(flatbuffers::EndianScalar(_y1)),
        y2_(flatbuffers::EndianScalar(_y2)),
        y3_(flatbuffers::EndianScalar(_y3)),
        z0_(flatbuffers::EndianScalar(_z0)),
        z1_(flatbuffers::EndianScalar(_z1)),
        z2_(flatbuffers::EndianScalar(_z2)),
        z3_(flatbuffers::EndianScalar(_z3)),
        w0_(flatbuffers::EndianScalar(_w0)),
        w1_(flatbuffers::EndianScalar(_w1)),
        w2_(flatbuffers::EndianScalar(_w2)),
        w3_(flatbuffers::EndianScalar(_w3)) {
  }
  float x0() const {
    return flatbuffers::EndianScalar(x0_);
  }
  void mutate_x0(float _x0) {
    flatbuffers::WriteScalar(&x0_, _x0);
  }
  float x1() const {
    return flatbuffers::EndianScalar(x1_);
  }
  void mutate_x1(float _x1) {
    flatbuffers::WriteScalar(&x1_, _x1);
  }
  float x2() const {
    return flatbuffers::EndianScalar(x2_);
  }
  void mutate_x2(float _x2) {
    flatbuffers::WriteScalar(&x2_, _x2);
  }
  float x3() const {
    return flatbuffers::EndianScalar(x3_);
  }
  void mutate_x3(float _x3) {
    flatbuffers::WriteScalar(&x3_, _x3);
  }
  float y0() const {
    return flatbuffers::EndianScalar(y0_);
  }
  void mutate_y0(float _y0) {
    flatbuffers::WriteScalar(&y0_, _y0);
  }
  float y1() const {
    return flatbuffers::EndianScalar(y1_);
  }
  void mutate_y1(float _y1) {
    flatbuffers::WriteScalar(&y1_, _y1);
  }
  float y2() const {
    return flatbuffers::EndianScalar(y2_);
  }
  void mutate_y2(float _y2) {
    flatbuffers::WriteScalar(&y2_, _y2);
  }
  float y3() const {
    return flatbuffers::EndianScalar(y3_);
  }
  void mutate_y3(float _y3) {
    flatbuffers::WriteScalar(&y3_, _y3);
  }
  float z0() const {
    return flatbuffers::EndianScalar(z0_);
  }
  void mutate_z0(float _z0) {
    flatbuffers::WriteScalar(&z0_, _z0);
  }
  float z1() const {
    return flatbuffers::EndianScalar(z1_);
  }
  void mutate_z1(float _z1) {
    flatbuffers::WriteScalar(&z1_, _z1);
  }
  float z2() const {
    return flatbuffers::EndianScalar(z2_);
  }
  void mutate_z2(float _z2) {
    flatbuffers::WriteScalar(&z2_, _z2);
  }
  float z3() const {
    return flatbuffers::EndianScalar(z3_);
  }
  void mutate_z3(float _z3) {
    flatbuffers::WriteScalar(&z3_, _z3);
  }
  float w0() const {
    return flatbuffers::EndianScalar(w0_);
  }
  void mutate_w0(float _w0) {
    flatbuffers::WriteScalar(&w0_, _w0);
  }
  float w1() const {
    return flatbuffers::EndianScalar(w1_);
  }
  void mutate_w1(float _w1) {
    flatbuffers::WriteScalar(&w1_, _w1);
  }
  float w2() const {
    return flatbuffers::EndianScalar(w2_);
  }
  void mutate_w2(float _w2) {
    flatbuffers::WriteScalar(&w2_, _w2);
  }
  float w3() const {
    return flatbuffers::EndianScalar(w3_);
  }
  void mutate_w3(float _w3) {
    flatbuffers::WriteScalar(&w3_, _w3);
  }
};
FLATBUFFERS_STRUCT_END(Mat4, 64);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Transform FLATBUFFERS_FINAL_CLASS {
 private:
  Mat4 matrix_;
  Mat4 inverseMatrix_;

 public:
  Transform() {
    memset(this, 0, sizeof(Transform));
  }
  Transform(const Mat4 &_matrix, const Mat4 &_inverseMatrix)
      : matrix_(_matrix),
        inverseMatrix_(_inverseMatrix) {
  }
  const Mat4 &matrix() const {
    return matrix_;
  }
  Mat4 &mutable_matrix() {
    return matrix_;
  }
  const Mat4 &inverseMatrix() const {
    return inverseMatrix_;
  }
  Mat4 &mutable_inverseMatrix() {
    return inverseMatrix_;
  }
};
FLATBUFFERS_STRUCT_END(Transform, 128);

}  // namespace serialization
}  // namespace pandora

#endif  // FLATBUFFERS_GENERATED_DATATYPES_PANDORA_SERIALIZATION_H_
