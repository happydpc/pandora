=== Wide Vector BVH traversal ===
AVX2 does not contain all required instructions => emulate (compact is kinda interesting, also because it has 2 options: more compute or using a LUT).



=== VOXELIZATION ===
No library that guarantees watertight results + most Github projects are CLI ==> have to write my own
Going to be based on: http://research.michael-schwarz.com/publ/files/vox-siga10.pdf because its conservative, modern and fast (well parallelizable)

Paper uses xy, xz and yz planes. They do not mention that for the xz plane the edge normal flip with respect to the 3D normal is reversed (flip if y >= 0.0f).
Alternatively they could have used the zx plane in which the flip matches that of xy and yz.
Not mentioned but certainly a good idea: skip projection overlap test for projection planes orthogonal to the triangle plane.

Optimization 1:
Splitting the code into a preprocess and intersect function (like in the paper) is a bad idea. More time is spent on memory allocation than on intersecting (for the Stanford Dragon).

Optimization 2:
Have separate triangle voxelization functions based on the triangles shape (moving code to different functions did not impact performance).
Separate case for triangles whose bounding box covers a single voxel

NOTE: more optimizations can be made which will improve the performance for large (wrt voxels) triangles. For my use-case I assume a low voxel resolution (compared to geometric complexity) so these optimizations are not worth my (development) time right now.

Optimization 3:
SIMD implementation using ISPC. Getting ISPC to compile through CMake is a bit dirty (CMakes fault, man the CMake language is disgusting).
Had to (re)-implement some basic functions because classes are not a thing in ISPC (C).
Wasted some time on the following bug: ISPC float<3> (or any other length) initializer list is different from most other vector languages:
float<3> x = { 1 }      ===>  only initializes first field (instead of broadcasting the value)
Debugging in ISPC is hard since there is no debugger support on Windows (just print statements).


=== Sparse Voxel Octree ===
Paper describes how to create a SVO from the voxel grid (in parallel) but I could not properly understand it.
Using another paper on out-of-core construction for now (leaving out the out-of-core stuff):
http://graphics.cs.kuleuven.be/publications/BLD13OCCSVO/BLD13OCCSVO_paper.pdf

Octree node layout based on "Efficient Sparse Voxel Octrees" (because its space efficient: 32 bits per node):
http://research.nvidia.com/sites/default/files/pubs/2010-02_Efficient-Sparse-Voxel/laine2010i3d_paper.pdf
The contour part is left out; images in the paper suggest that they are conservative. But it uses more memory, removes the possibility for DAGs, and would not improve occlusion culling by that much.
For now, the table approach is also left out, assuming that 16 bit offsets (from the start of the array) are enough to store the entire tree.

Implementation is quite straight forward although the paper is not super clear on how to replace fully empty/filled nodes by a single parent.

=== Traversal ===
Based on:
http://research.nvidia.com/sites/default/files/pubs/2010-02_Efficient-Sparse-Voxel/laine2010i3d_paper.pdf

Stripped out the part about contours.
Algorithm seems to assume rays where tfar is indicated by the length of the direction vector (and tnear = 0.0).
So leave out the tmax = min(tmax, 1.0f) part