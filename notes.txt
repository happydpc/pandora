=== Wide Vector BVH traversal ===
AVX2 does not contain all required instructions => emulate (compact is kinda interesting, also because it has 2 options: more compute or using a LUT).



=== VOXELIZATION ===
No library that guarantees watertight results + most Github projects are CLI ==> have to write my own
Going to be based on: http://research.michael-schwarz.com/publ/files/vox-siga10.pdf because its conservative, modern and fast (well parallelizable)

Paper uses xy, xz and yz planes. They do not mention that for the xz plane the edge normal flip with respect to the 3D normal is reversed (flip if y >= 0.0f).
Alternatively they could have used the zx plane in which the flip matches that of xy and yz.
Not mentioned but certainly a good idea: skip projection overlap test for projection planes orthogonal to the triangle plane.

Optimization 1:
Splitting the code into a preprocess and intersect function (like in the paper) is a bad idea. More time is spent on memory allocation than on intersecting (for the Stanford Dragon).

Optimization 2:
Have separate triangle voxelization functions based on the triangles shape (moving code to different functions did not impact performance).
Separate case for triangles whose bounding box covers a single voxel

NOTE: more optimizations can be made which will improve the performance for large (wrt voxels) triangles. For my use-case I assume a low voxel resolution (compared to geometric complexity) so these optimizations are not worth my (development) time right now.

Optimization 3:
SIMD implementation using ISPC. Getting ISPC to compile through CMake is a bit dirty (CMakes fault, man the CMake language is disgusting).
Had to (re)-implement some basic functions because classes are not a thing in ISPC (C).
Wasted some time on the following bug: ISPC float<3> (or any other length) initializer list is different from most other vector languages:
float<3> x = { 1 }      ===>  only initializes first field (instead of broadcasting the value)
Debugging in ISPC is hard since there is no debugger support on Windows (just print statements).


=== Sparse Voxel Octree ===
Paper used for SVO construction:
http://graphics.cs.kuleuven.be/publications/BLD13OCCSVO/BLD13OCCSVO_paper.pdf

Octree node layout based on "Efficient Sparse Voxel Octrees":
http://research.nvidia.com/sites/default/files/pubs/2010-02_Efficient-Sparse-Voxel/laine2010i3d_paper.pdf
The contour part is left out; images in the paper suggest that they are conservative. But it uses more memory, removes the possibility for DAGs, and would not improve occlusion culling by that much.
For now, the jump table is also left out; assuming that 16 bit offsets (from the start of the array) is enough to store the entire tree.

TODO: make leaf nodes 16 bit in size by removing the (unused) first child offset
TODO: improve performance by switching to the more complicated algorithm presented in the paper


=== Traversal ===
Based on:
http://research.nvidia.com/sites/default/files/pubs/2010-02_Efficient-Sparse-Voxel/laine2010i3d_paper.pdf
Stripped out the part about contours.

Algorithm seems to assume rays where tfar is indicated by the length of the direction vector (and tnear = 0.0).
So leave out the tmax = min(tmax, 1.0f) part

Not mentioned in the paper but used explicitely in the code: stack size of 23+1 because scale becomes 24 when it gets be low 1.0

=> Uses normal casting, reinterpret casting, bitshifting and arithmatic to compute the highest differing bit (computing scale in POP). Could use bitscan instead (probably faster + easier to reason about).

Reinterpet int to float to efficiently & precisely calculate scaleExp2


=== Sparse Voxel DAG compression ===
For compression the nodes need to be visited in breadth-first order. The construction method used for the SVO constructs the tree depth first. This means that all nodes of a single level are NOT all adjacent in memory. All nodes of a single level could be extracted through a breadth-first traversal.

Because of performance concerns I plan instead on using a different (slightly more complicated) breadth-first construction algorithm based on the voxelization paper. The paper voxelizes the mesh twice, once for allocating the octree nodes and the second time to fill the leaf nodes. The paper also suggests some changes to make the resulting SVO 6-seperating although the algorithm can be adjusted to make it conservative.

In my work I'm not concerned with parallel construction of the SVO nor with very strict memory requirements because the models are thought to be very compact. So I will keep voxelization completely seperated from SVO construction. In practice, the algorithm skips the first paragraph of section 5.1 and does not keep track of x-neighbours or parent pointers.

NOTE: the data layout suggested in the paper is not sparse (it subdivides to the lowest level) for fully filled regions. I use an extra 8 bit mask (in memory that would have otherwise have been unused) to store which children are leafs (just like in Efficient Sparse Voxel Octrees).


Using relative offsets makes current DAG compression impossible (nodes in the old array are updated to store a reference to a node in the new array of nodes => using relative offsets doesnt work).
Create a separate array of indirection for each SVO (from unique node idx to absolute offset in the new array). This should give us some headroom (number of unique nodes still limited to 16 bits).

NOTE: compressing child nodes & keeping indices to parents misses nodes that are the same but on a different level

This would be so much easier on a single tree; can be integrated into SVO construction